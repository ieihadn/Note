当你手里有把锤子的时候，看所有的东西都是钉子。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191130235430272.png)
有时候程序员往往会陷入为了写代码而写代码的怪圈，没有意识到代码是为了解决现实问题的。当问题有更简便的解决方案时，写代码未必就是必须。记住：你不是别人花钱让你在屏幕上写字符的程序猿，而是让你解决问题的专业人士。Fagner Brack 的总结非常有见地。



锤子摆在一块木板上。木板有一颗被锤弯的钉子。






程序员似乎已经忘记了软件的真正目的是什么，是解决现实世界的问题。



50 年前的 1968 年开过一场会，会议名字叫做软件工程工作会议，是有 NATO 科学委员会赞助的。那时候大家已经开始注意到软件日益成为社会的基础。然而，软件也变得太难以理解。在那次会议之后，变成开始变成一个行业。软件开始摆脱商业人士的控制。



不管软件此后走上了什么样的发展道路，仍然存在着业务与软件开发（或者按照那次会议首次的说法，“工程”）分离的问题。如果开发者太过狭隘地专注于开发，就会错过了他们编写的软件背后的目的。以至于可能会看不到并不需要编写任何代码的潜在解决方案。



举个例子。



有一家初创企业是做设备的，这种设备可以让人利用蓝牙解锁开门。跟这种设备进行通信的可视化界面是一个小程序，就算是门锁上它也能看见。这个玩意儿有一个按钮叫做 “开门”。



当用户接近房子时，他们会拿出手机，找到那个小程序，然后点击按钮开门。



有人看过这套流程之后问道：



如果我们用的是蓝牙并且假设拿着这部手机的任何人都能进入房子的话，为什么还需要让某人拿出手机然后按按钮呢？当它检测到设备距离在 1 米之内时让们打开不就行了吗。这样我们就不用付出设计和编写可视化界面的成本了！



这个蓝牙应用的故事是聚焦过窄的绝佳例子：目标是用尽量方便地开门。如果传感器是无线的话设计可视化界面毫无意义。



如果你意识到企业想要实现什么以及对用户的价值是什么的话，你可以将哪方面的知识跟你对技术可能做到什么的知识融为一体。只有这样你才会具备足够的信息来想出更好的答案并且得出结论说界面对产品来说毫无必要。



这是一个解决编程问题的出色例子——除了编写解锁功能以外再无编写任何额外代码之必要。然而，就像技术债务一样，任何东西都不应该用来作为编写垃圾代码的借口。




# 不是所有的代码都值得编写




有时候，修补重大 bug 未必是优先事项。假设你是加密数字货币交易所，如果你的系统允许出现一次账户副本的话，人为干预会是成本效益最佳的解决方案——如果修补漏洞的代价很大的话。



严重性于优先级之间的权衡让我想起了同事最近给我看过的一种模型。这个模型叫做优先级矩阵这是一个二维模型，可用于确定 bug 的优先级，其根据是影响到的用户数以及严重性。




![在这里插入图片描述](https://img-blog.csdnimg.cn/20191130235412476.png)


二维优先级矩阵图示。Y 轴表示受影响的用户，分别包含 “一个”、“一些” 以及 “全部” 这些值。X 轴表示 “严重性，值包括 “界面性”、“造成不便” 以及 “无法工作”。Bug 的优先级多少要取决于它在坐标上的位置。



比方说，如果 ug 是界面性的而且仅影响到一个用户的话，则优先级为 4；如果 bug 让某人无法工作而且影响到一些人的话，则优先级为 1；如果 bug 导致所有人都无法工作的话，则优先级为最高，0。



前面说过的单账户副本问题算是影响了一个用户的使用便利性这类，因此其优先级为 3。



# 不是所有的 bug 都值得修复




开发者想给一切都写脚本是非常常见的。然而，一些重复性的任务未必值得自动化。如果你打算隐藏一些有关底层命令如何工作的基本知识的话，就不需要花时间去写脚本了。



服装复杂逻辑和抽象有用知识之间是有区别的。有时候，信息应该明确表示方便理解。如果你对信息进行了抽象的话，可能反而产生相反效果并且难以理解。



在 CLI 里面使用一些类型的低级命令而不是抽象了知识的高级命令（如 Git aliases）会更有用。



# 并不是所有的命令都值得写脚本




几年前我用 Incremental Delivery 做了一个项目。这是一个身份验证系统，系统会让用户提交一些个人数据，让第三方提供商进行验证。



团队想要开发一个非常棒的字段验证功能。然而，验证这个功能每次 sprint 计划都被列到低优先级的位置，眼看着截止期限越来越近了。到最后，团队发现这项功能根本就没有必要。



原因是：验证是必须的！



提供合法信息关乎用户的利益。如果用户提供的数据是错的，验证就不会通过也就无法使用系统。此外，大多数浏览器都支持标准的 HTML 验证，这已经足够了。



最糟糕的情况下，本人无法验证通过的用户会打电话给支持进行人工验证。





# 不是每一项功能都值得编写




作为开发者，如果你理解了自己试图要解决的问题的话，你就能想出更好的代码，甚至有时候根本不需要编码。你不是别人花钱让你在屏幕上写字符的程序猿。你是别人花钱来帮忙解决问题的专业人士。



不过，如果试图不经思考只想用技术解决每一个问题，就好像把代码当成银弹的话，你就很难理解什么东西对客户有价值，也很难想出很好的点子。



你的目的以及所写代码的目的都是为了产生价值，让世界更美好，而不是为了满足你以自我为中心的世界观。



有句话是这么说的：“当你手里有把锤子的时候，看所有的东西都是钉子。”



最好还是先有颗钉子这样你才会考虑需要一把锤子。



也就是说，如果你本来就需要钉子的话。