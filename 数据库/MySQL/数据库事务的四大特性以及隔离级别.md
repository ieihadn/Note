# 数据库事务
本篇文章主要介绍数据库事务的四大特性ACID，以及数据库的隔离级别。

## 概念
事务指的是满足 ACID 特性的一系列操作。在数据库中，可以通过 Commit提交一个事务，也可以使用 Rollback 进行回滚。
## 四大特性
1. 原子性（Atomicity）：事务被视为不可分割的最小单元，要么全部提交成功，要么全部失败回滚。
2. 一致性（Consistency）：事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
3. 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的。
4. 持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来保证持久性。

在了解完数据库的四大特性之后，我们来讨论一下数据库的隔离级别的问题。在此之前，我们考虑在没有数据库隔离性的情况下，多用户并发操作可能会发生的问题。

## 并发一致性问题
在并发环境下，一个事务如果受到另一个事务的影响，那么事务操作就无法满足一致性条件。


1. 丢失修改：多个事务同时读取某一数据，一个事务成功处理好了数据，被另一个事务写回原值，造成第一个事务更新丢失。例如，T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。
2. 脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。例如，T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
3. 不可重复读：不可重复读是指在对于数据库的某个数据，一个事务范围内多次查询却返回了不同的数据值。这是由于在查询间隔，被另一个事务修改并提交了。例如，T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和和第一次读取的结果不同。
4. 幻读（虚读）：幻读是事务非独立执行时发生的一种现象。例如，T1 读取某个范围的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

## 解决方法
产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作都要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

现在我们来看下事务的四种隔离级别。

## 隔离级别
1. 未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。最低级别，任何情况都无法保证。
2. 提交读（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。可避免脏读的发生。
3. 可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同样数据的结果是一样的。可避免脏读、不可重复读的发生。
4. 可串行化（SERIALIXABLE）：强制事务串行执行。可避免脏读、不可重复读、幻读的发生。

四种隔离级别的对比

隔离级别|脏读|不可重复读|幻读
---|---|---|---
未提交读|YES|YES|YES
提交读|NO|YES|YES
可重复读|NO|NO|YES
可串行化|NO|NO|NO

以上四种隔离级别最高的是SERIALIXABLE（可串行化）级别，最低的是READUNCOMMITTED（未提交读）级别，当然级别越高，执行效率就越低。像SERIALIXABLE（可串行化）这样的级别， 就是以锁表的方式使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。

在MySQL数据库中，支持上面四种隔离级别，默认的为REPEATABLE READ(可重复读)；而在Oracle数据库中，只支持SERIALIXABLE(串行化)级别和READCOMMITTED(读已提交)这两种级别 ，其中默认的为READ COMMITTED级别。